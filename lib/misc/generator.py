from itertools import combinations_with_replacement
from string import ascii_uppercase, ascii_lowercase, ascii_letters
from re import finditer


class Generator(object):
    """
        This class is a items' generator for use to brute force exploit
    """

    def __init__(self):
        """Initialize the generator and all attributes that it needs"""
        self.__items = None
        self.__pattern = None
        self.__ranges = []
        self.__lengths = []

    def check(self, pattern, lengths=""):
        """
        This function check that patterns an their lengths are correct.
        :param pattern: the pattern
        :param lengths: the pattern's lengths
        :return:
        """
        if len(lengths) > 0:
            lengths = lengths.split(",")
            if lengths[-1:] == '':
                lengths = lengths[:-1]
            try:
                # Check that all lengths are positive
                if filter(lambda x: x, [int(i) for i in lengths if int(i) <= 0]):
                    return False
            except ValueError:
                return False

            # Search all ranges
            self.__pattern = pattern
            ranges = self.findRange()

            # All ranges have length
            if len(lengths) == len(ranges):
                self.__ranges = ranges
                self.__lengths = lengths
                return True
            else:
                return False
        else:
            self.__pattern = pattern
            return True

    def create(self):
        """
        This function create array with all combinations
        :return: array with all combinations
        """
        pattern = [self.__pattern]
        result = self.combinationRange(pattern, self.__lengths, self.__ranges)

        return result

    def findRange(self):
        """
        This function find all ranges that appear on the pattern
        :return: array with ranges like '[a-z]'
        """
        ranges = []

        try:
            start = [m.start() for m in finditer('\[', self.__pattern)]
            end = [m.start() for m in finditer('\]', self.__pattern)]
        except TypeError:
            return ranges

        if len(start) == len(end):
            for x in map(None, start, end):
                # x[0] range start x[1] range end
                values = self.__pattern[(int(x[0]) + 1):x[1]]
                if "-" in values:
                    ranges.append(self.__pattern[(int(x[0]) + 1):x[1]])
                else:
                    return []

        return ranges

    def splitRange(self, pattern):
        """
        This function split the range and identify it him type
        :param pattern: the pattern
        :return: a var like 'a-z'
        """
        out = ""
        try:
            items = pattern.split("-")
            first = items[0]
            last = items[1]
            if first == "" or last == "":
                return out
        except IndexError:
            return out

        if first in ascii_lowercase and last in ascii_uppercase:
            out = ''.join([chr(i) for i in range(ord(first), ord('z') + 1)]) + ''.join(
                [chr(i) for i in range(ord('A'), ord(last) + 1)])
        elif first in ascii_letters and last in ascii_letters:
            out = ''.join([chr(i) for i in range(ord(first), ord(last) + 1)])
        elif int(first) in range(0, 9) and int(last) in range(0, 9):
            out = ''.join("{}".format(i) for i in range(int(first), int(last) + 1))

        return out

    def combinationRange(self, pattern, lengths, ranges):
        """
        Recursive function that create all possibilities
        :param pattern: the pattern
        :param lengths: the pattern's lengths
        :param ranges:
        :return: all patterns
        """
        if not pattern:
            return None

        if lengths and ranges:
            newPattern = []

            # Get first range and first length
            r = ranges.pop(0)
            l = int(lengths.pop(0))

            myRange = self.splitRange(r)
            if not myRange:
                return None

            comb = combinations_with_replacement(myRange, l)
            try:
                while True:
                    result = [''.join(comb.next())][0]
                    replace = "[" + r + "]"
                    for p in pattern:
                        newPattern.append(p.replace(replace, result, 1))
            except StopIteration:
                pass

            return self.combinationRange(newPattern, lengths, ranges)
        else:
            return pattern
