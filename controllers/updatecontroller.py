# Imports
from json import dump, load
from os import listdir, walk, getcwd, makedirs
from os.path import splitext, join, isfile, exists
from shutil import copy2

from lib.io.network import downloadFile
from lib.misc.parse import fileToHash, stringToHash
from views.dialog.updateview import UpdateView


class UpdateController(object):

    """
        This class is a controller that manages the update system.
    """

    def __init__(self):
        self.__serverFile = "server.json"
        self.__updateFile = "update.json"
        self.__URL = None
        self.__view = UpdateView(self)
        self.__updates = []

    def createJSONLocal(self):
        """
        Create a json local named 'update.json'
        :return: None
        """

        fileJSON = self.writeJSON("auxiliary")
        fileJSON.update(self.writeJSON("generic"))
        fileJSON.update(self.writeJSON("routers"))

        checksum = "{0}{1}{2}".format(fileJSON['generic']['id'],
                                      fileJSON['auxiliary']['id'],
                                      fileJSON['routers']['id'])

        # Checksum from modules folder
        checksum = stringToHash(checksum)
        data = {"modules": fileJSON, "id": checksum}

        with open(self.__updateFile, "w+") as outfile:
            dump(data, outfile, indent=4)

    def downloadUpdates(self, items):
        """
        Download all new items
        :param items: items that we want download
        :return: None
        """
        base = join(getcwd() + "/")
        for item in items:
            item = item[0]
            path = join(base, item['path'])
            url = '{0}/{1}'.format(self.__URL, item['path'])
            try:
                downloadFile(path, url)
            except IOError:
                # If we found a new folder we will create a package
                path = "/".join(path.split("/")[:-1])
                # Create a folder with a __init__.py file. It is a python package
                if not exists(path):
                    makedirs(path)
                # Create a package with a __init__.py file
                open(join(path, "__init__.py"), 'w')

                downloadFile(join(path, item['path']), url)

    @staticmethod
    def filesToJSON(path, pathUrl):
        """
        Write a JSON about a file
        :param path: the path
        :param pathUrl: the string that will appear on value of key 'path'
        :return: a structure JSON
        """
        out, checksumPath = [], ""
        folder = path.split("/")[-2]

        if path.split("/")[-2] in pathUrl:
            pathUrl = ""

        files = filter(lambda x: x,
                       [[join(path + splitext(f)[0] + splitext(f)[1]), splitext(f)[0]]
                        for f in listdir(path)
                        if f.endswith(".py") and not f.startswith("__")])

        for f in files:
            path, name = f
            checksumFile = fileToHash(path)

            data = {"name": "{}".format(name),
                    "id": checksumFile,
                    "path": join("modules", pathUrl, folder + "/" + "{0}.py".format(name))}

            # Create a checksum of all checksum's
            checksumPath += checksumFile
            out.append(data)

        folder = {"folder": folder,
                  "id": stringToHash(checksumPath),
                  "files": out}

        return folder

    @staticmethod
    def getItemsDiff(local, remote, new):
        """
        Return the items that we must download (new or update)
        :param local: file local update.json
        :param remote: file remote server.json
        :param new: new items
        :return: a list with all new or update items
        """
        items = []
        for item in remote:
            # Update
            update = [item for x in local
                      if x['name'] == item['name'] and x['id'] != item['id']]

            if update:
                items += update

            # Add
            add = [item for x in new if x == item['name']]

            if add:
                items += add

        return items

    def getFilesToUpdate(self):
        """
        Search on each folder any differences
        :return: three items (auxiliary exploits, generic exploits, routers exploits)
        """
        local, remote = self.getJSONFiles()
        if local and remote and local['id'] != remote['id']:
                local = local['modules']
                remote = remote['modules']

                # auxiliary
                auxiliary = self.searchFilesOnFolder('auxiliary', local, remote)

                # generic
                generic = self.searchFilesOnFolder('generic', local, remote)

                # routers
                routers = self.searchFilesOnFolder('routers', local, remote)

                return auxiliary, generic, routers
        else:
            return [], [], []

    @staticmethod
    def searchDifferences(local, remote, key):
        """
        Search difference between local and remote array compare them by 'key'
        :param local: local file update.json
        :param remote: server file server.json
        :param key: 'value' we want compare
        :return: a list with items different
        """
        remote = [x[key] for x in remote]
        local = [x[key] for x in local]

        # Searching differences between local and remote files
        return list(set(remote).difference(local))

    def searchFilesOnFolder(self, folder, local, remote):
        """
        Search all files from a folder. Also compare all them by 'id' value
        :param folder: a folder between 'auxiliary', 'generic' or 'routers
        :param local: local file update.json
        :param remote: server file server.json
        :return: a array with all items that we must download
        """
        items = []
        try:
            if remote[folder]['id'] != local[folder]['id']:
                if folder in ['auxiliary', 'generic']:
                    new = self.searchDifferences(local[folder]['files'], remote[folder]['files'], 'name')
                    elements = self.getItemsDiff(local[folder]['files'], remote[folder]['files'], new)
                    items.append(elements)

                elif folder in ['routers']:
                    for item in remote[folder]['files']:
                        # Get a folder whose id is different and exist locally
                        folders = [x for x in local[folder]['files']
                                   if x['folder'] == item['folder'] and x['id'] != item['id']]

                        # Get all items's folder
                        if folders:
                            localName = [x['files'] for x in folders][0]
                            remoteName = item['files']

                            new = self.searchDifferences(localName, remoteName, 'name')
                            elements = self.getItemsDiff(localName, remoteName, new)
                            items += elements

                    # Add new routers
                    newFolders = self.searchDifferences(local[folder]['files'], remote[folder]['files'], 'folder')

                    for item in remote[folder]['files']:
                        add = [item for x in newFolders if x == item['folder']]
                        if add:
                            items += add

        except KeyError:
            pass
        finally:
            return items

    def getJSONFiles(self):
        """
        Get a JSON files need for compare them.
        :return: local a update.json file remote is a server.json
        """
        self.createJSONLocal()
        path = join(getcwd(), self.__updateFile)
        with open(path) as dataFile:
            local = load(dataFile)

        # Download file from server
        path = join(getcwd(), self.__serverFile)
        url = '{0}/{1}'.format(self.__URL, self.__serverFile)
        if downloadFile(path, url):
            with open(path) as dataFile:
                remote = load(dataFile)

            return local, remote
        else:
            return None, None

    def show(self):
        self.__view.exec_()

    def update(self, IP):
        """
        Starting update system
        :return: None
        """

        if IP.startswith("http://") or IP.startswith("https://"):
            self.__URL = IP
        else:
            self.__URL = "http://{0}".format(IP)

        auxiliary, generic, routers = self.getFilesToUpdate()

        self.__view.setExploitsUpdated(len(auxiliary), len(generic), len(routers))
        self.__updates.append(auxiliary)
        self.__updates.append(generic)
        self.__updates.append(routers)

        return len(auxiliary), len(generic), len(routers)

    def upgrade(self):
        """
        Starting upgrade system
        :return:
        """
        for u in self.__updates:
            self.downloadUpdates(u)

        # Replace update.json file by server.json
        destination = self.__updateFile
        source = self.__serverFile

        try:
            if isfile(source):
                copy2(source, destination)
                return True
        except EOFError:
            return False

    def writeJSON(self, folder):
        """
        Write a JSON about a folder and it can be 'routers', 'auxiliary' or 'generic
        :param folder: 'routers', 'auxiliary' or 'generic
        :return: a structure JSON like {'namefolder': data'}
        """
        path = join(getcwd(), "modules", folder + "/")
        out, data = [], {}

        if folder == "routers":
            checksum = ""
            for root, dirs, files in walk(path, topdown=False):
                for d in dirs:
                    data = self.filesToJSON(join(path, d + "/"), folder + "/")
                    checksum += data['id']
                    out.append(data)

            data = {"folder": folder,
                    "id": stringToHash(checksum),
                    "files": out}

        elif folder in ['auxiliary', 'generic']:
            data = self.filesToJSON(path, folder + "/")
        else:
            pass

        return {folder: data}
