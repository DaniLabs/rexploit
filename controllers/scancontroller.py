from lib.scan.communicate import Communicate
from lib.scan.parse import itemToTarget, sectionsToTargets
from lib.scan.profiles import Profiles
from lib.scan.scanthread import ScanThread
from views.dialog.newprofileview import NewProfileView
from views.misc.messagebox import MessageBox
from views.widgets.scanview import ScanView


class ScanController(object):
    def __init__(self, parent):
        self.__communicate = Communicate()
        self.__scanThread = ScanThread(self.__communicate)
        self.__scanView = ScanView(self, parent)
        self.__newProfileView = NewProfileView(self)
        self.__profiles = Profiles()
        self.__projectFile = None
        self.__IP = None

        # Connect signal
        self.__communicate.finish.connect(self.__scanView.setItemsScanned)

    def cancel(self):
        self.__scanThread.terminate()
        self.__scanView.restartView()

    def createProfile(self):
        self.__newProfileView.setProfiles(self.__profiles)

        value = self.__newProfileView.exec_()

        while value < 0:
            value = self.__newProfileView.exec_()

        if value > 0:
            self.__scanView.setPushButtonRemoveProfileEnabled(True)
            return True
        elif value == 0:
            return False

    def getCommand(self, profile):
        return self.__profiles.getCommand(profile, "command")

    def getItemsTable(self):
        targets = []
        row, col = self.__scanView.rowColCount()

        for i in xrange(row):
            item = map(lambda j: self.__scanView.getItem(i, j), range(col))
            targets.append(itemToTarget(item))

        return targets

    def getItemsProjectFile(self):
        i = 0
        items = []
        while self.__projectFile.hasSection("Target_%s" % i):
            items.append(self.__projectFile.readSection("Target_%s" % i))
            i += 1

        self.__scanView.setItemsLoaded(sectionsToTargets(items))

    def getWidget(self):
        return self.__scanView

    def loadProfiles(self):
        profiles = self.__profiles.getProfiles()
        self.__scanView.addProfiles(profiles)

    def removeProfile(self, profile):
        if MessageBox.question("Remove Profile", "Do you want remove this profile \'{0}\' ".format(profile)):
            self.__profiles.removeProfile(profile)
            self.loadProfiles()
        else:
            pass

    def saveTargets(self):
        targets = self.getItemsTable()
        if targets:
            for i, target in enumerate(targets):
                section = "Target_%s" % i
                try:
                    if not self.__projectFile.readValue(section, "Port") == target.getPort():
                        self.__projectFile.write(section, "Protocol", target.getProtocol())
                        self.__projectFile.write(section, "Port", target.getPort())
                        self.__projectFile.write(section, "Name", target.getName())
                        self.__projectFile.write(section, "State", target.getState())
                        self.__projectFile.write(section, "Product", "{0} {1}".format(target.getProduct(), target.getVersion()))
                        self.__projectFile.write(section, "Extra", target.getInfo())
                except Exception as e:
                    MessageBox.critical("Error", e.message)

    def setProjectFile(self, projectFile, new):
        self.__projectFile = projectFile
        self.__IP = str(self.__projectFile.readValue("Information", "IP"))
        if not new:
            self.getItemsProjectFile()
        else:
            self.__scanView.restartView()

    def start(self, arguments):
        if not self.__IP:
            MessageBox.critical("Error", "IP not found")
        elif not arguments:
            MessageBox.critical("Error", "Command is empty")
        elif self.__scanThread.isRunning():
            MessageBox.critical("Error", "A scanning is running")
        else:
            self.__scanView.activateScanView()
            self.__scanThread.setHost(self.__IP)
            self.__scanThread.setArguments(arguments)
            self.__scanThread.start()
